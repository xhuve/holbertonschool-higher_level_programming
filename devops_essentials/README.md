
# Docker Essentials

## 0. Create a Simple Docker Image Locally Based on Alpine

### Step 1: Create the Dockerfile
- Open the Dockerfile in your preferred editor (e.g., VS Code).
- Add the following content to the Dockerfile:
```bash
FROM alpine:latest
CMD ["echo", "Hello, World!"]
```

### Step 2: Build the Docker Image
- Open a terminal and make sure to be at the `docker-alpine-hello` directory 
- Build the Docker image using the docker `build` command
```bash
docker build -t hello-alpine .
```
Once the build is complete, you'll have a new image tagged as `hello-alpine`.

### Step 3. Run the Docker Container
- Run a container based on the `hello-alpine` image using the docker `run` command:
```bash
docker run hello-alpine
```

## Task 1. Customize Your Alpine-based Docker Image

### Step 1: Create the `config.txt` File
- In your `docker-alpine-hello` directory, create a file named `config.txt`
```bash
echo "Welcome to Docker!" > config.txt
```

### Step 2: Modify the `Dockerfile`
- Open your existing `Dockerfile` in the `docker-alpine-hello` directory and modify it to include the installation of curl and to copy the `config.txt` file into the image.
- Update the `Dockerfile` to:
```bash
# Use the official Alpine image from the Docker Hub
FROM alpine:latest

# Install curl
RUN apk add --no-cache curl

# Copy the config.txt file into the container
COPY config.txt /app/config.txt

# Define the command to run when the container starts
CMD ["echo", "Hello, World!"]
```

### Step 3. Build the Extended Docker Image
- Build the Docker image with a new tag
```bash
docker build -t extended-hello-alpine .
```

### Step 4: Test the Docker Container

#### Test the Docker container
Run a container from the newly created image and test the `curl` command:
Example: `docker run extended-hello-alpine curl https://jsonplaceholder.typicode.com/users`

You should see the content of the json placeholder api (users) printed in the terminal, which confirms that curl is installed and working.

#### Confirm the existence and content of the `config.txt` file

```bash
docker run extended-hello-alpine cat /app/config.txt
```

You should see `Welcome to Docker!` printed in the terminal, confirming that the config.txt file is correctly copied into the container.

## 2. Automate Container Image Build and Push Using GitHub Actions

### Preconditions
- Make sure you have a personal access token with the necessary privileges
- Add the `PAT` as a GitHub Secret:
    - In your GitHub repository, go to `Settings > Secrets and variables > Actions` and in `New repository secret` add your PAT

### Step 1. Set Up GitHub Actions Workflow
- Create a GitHub Actions Workflow:
    - Create a file named `docker-image.yml` in `.github/workflows/`.
    - Add the following content to `docker-image.yml`

```bash
name: Build and Push Docker Image

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build Docker Image
        run: docker build -t ghcr.io/${{ github.repository_owner }}/holbertonschool_higher_level_programming:latest -f devops_essentials/github_actions/Dockerfile devops_essentials/github_actions

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CR_PAT }}

      - name: Push Docker Image
        run: docker push ghcr.io/${{ github.repository_owner }}/holbertonschool_higher_level_programming:latest
```
- Stage, commit, and push your changes to GitHub

- Verify the Workflow Execution
    - Go to the Actions tab in your GitHub repository.
    - You should see the workflow running. Monitor the workflow to ensure it completes successfully.

## 3. Persist Data Using Volumes
### Preconditions
- Create a data directory within docker-volumes, that contains a non-empty hello.txt file.

### Step 1. Create the docker file
```
FROM alpine:latest

VOLUME /data

CMD ["cat", "/data/hello.txt"]

```

- `VOLUME /data`: This line creates a Docker volume at the `/data` directory inside the Docker container. A Docker volume is a mechanism for persisting data generated by and used by Docker containers.

- `CMD ["cat", "/data/hello.txt"]`: This line sets the default command to be executed when a Docker container is run from the Docker image. In this case, the command is `cat /data/hello.txt`, which will output the contents of the `hello.txt` file located in the `/data` volume.


### Step 2. Build the docker and run the container

#### Build the docker using 

``` docker build -t my-data-container . ```

#### Run the docker image using 

``` docker run -v ./data:/data my-data-container ```

When running the Docker container with the -v flag, we provide two fields separated by a colon (:).

The first field (`./data`) specifies the local directory path that we want to mount into the Docker container. The second field (`/data`) specifies the directory path inside the Docker container where we want the local directory to be mounted.

Once we run the command, `CMD ["cat", "/data/hello.txt"]` should print whatever `hello.txt` has inside.


## 4. Set Up a Simple Infrastructure Using Docker Compose

### Preconditions
- Ensure Docker is installed on your system.
- Ensure you have a working internet connection to pull Docker images.
- Create a `docker-compose.yml` file with the following content.

### Step 1. Create the docker-compose.yml file

```yaml

services:
  db:
    image: postgres
    environment:
      - POSTGRES_PASSWORD=testpass
    networks:
      - private_network

  admin:
    image: dpage/pgadmin4:latest
    environment:
      - PGADMIN_DEFAULT_EMAIL=billyjean@admin.org
      - PGADMIN_DEFAULT_PASSWORD=Billyjeaning
    networks:
      - private_network
    ports:
      - "8080:80"
    depends_on:
      - db

networks:
  private_network:

```

#### Code explanation

- Create 2 services, one for the database itself, and one for an admin page for said database. The image links are documented in the Holberton site, and are also provided below. 
- Specifying a private network on which these services will be hosted.

#### Db(database) service

- Use a Postgres DB the image and documentation of which are [here](https://hub.docker.com/_/postgres).
- Host it on the private network and definig a password as an enviroment variable for the database.

#### Admin service

- Use the pgadmin image to load an admin page for the Postgress database. The image and documentations are located [here](https://hub.docker.com/r/dpage/pgadmin4/).

- Add `depends_on` with the db service name, thus specifying that the `db` service needs to load before this one.
- Add an email and password as enviroment variables which you will use to login once we host the admin page.
- Specify the private_network.
- Add the ports, the first port specifies where the page will load on your localhost. The second port specifies where pgadmin is hosted by default(in my case it was 80).

### Step 2. Run with Docker Compose

Run `docker-compose up` and wait for all the nessecary operations to be completed.

The console should return something like this
```
admin-1  | postfix/postlog: starting the Postfix mail system
admin-1  | [2024-06-03 11:12:15 +0000] [1] [INFO] Starting gunicorn 20.1.0
admin-1  | [2024-06-03 11:12:15 +0000] [1] [INFO] Listening at: http://[::]:80 (1)
admin-1  | [2024-06-03 11:12:15 +0000] [1] [INFO] Using worker: gthread
admin-1  | [2024-06-03 11:12:15 +0000] [117] [INFO] Booting worker with pid: 117
```

when the operation has concluded successfully.

That means that you can now access the Postgres admin page on [`http://localhost:8080/`](http://localhost:8080/).
Once there you can enter the email and password you specified in the enviroment variables earlier, click login, and you now have access to the Admin page of your own Postgres database, within Docker Compose.
